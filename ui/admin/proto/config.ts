// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.2
//   protoc               v3.21.12
// source: config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "config";

export enum OAuthProviderId {
  OAUTH_PROVIDER_ID_UNDEFINED = 0,
  CUSTOM = 1,
  DISCORD = 10,
  GITLAB = 11,
  GOOGLE = 12,
  UNRECOGNIZED = -1,
}

export function oAuthProviderIdFromJSON(object: any): OAuthProviderId {
  switch (object) {
    case 0:
    case "OAUTH_PROVIDER_ID_UNDEFINED":
      return OAuthProviderId.OAUTH_PROVIDER_ID_UNDEFINED;
    case 1:
    case "CUSTOM":
      return OAuthProviderId.CUSTOM;
    case 10:
    case "DISCORD":
      return OAuthProviderId.DISCORD;
    case 11:
    case "GITLAB":
      return OAuthProviderId.GITLAB;
    case 12:
    case "GOOGLE":
      return OAuthProviderId.GOOGLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OAuthProviderId.UNRECOGNIZED;
  }
}

export function oAuthProviderIdToJSON(object: OAuthProviderId): string {
  switch (object) {
    case OAuthProviderId.OAUTH_PROVIDER_ID_UNDEFINED:
      return "OAUTH_PROVIDER_ID_UNDEFINED";
    case OAuthProviderId.CUSTOM:
      return "CUSTOM";
    case OAuthProviderId.DISCORD:
      return "DISCORD";
    case OAuthProviderId.GITLAB:
      return "GITLAB";
    case OAuthProviderId.GOOGLE:
      return "GOOGLE";
    case OAuthProviderId.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * / Sqlite specific (as opposed to standard SQL) constrained-violation
 * / resolution strategy upon insert.
 */
export enum ConflictResolutionStrategy {
  CONFLICT_RESOLUTION_STRATEGY_UNDEFINED = 0,
  /** ABORT - / SQL default: Keep transaction open and abort the current statement. */
  ABORT = 1,
  /** ROLLBACK - / Abort entire transaction. */
  ROLLBACK = 2,
  /**
   * FAIL - / Similar to Abort but doesn't roll back the current statement, i.e. if the
   * / current statement affects multiple rows, changes by that statement prior
   * / to the failure are not rolled back.
   */
  FAIL = 3,
  /** IGNORE - / Skip the statement and continue. */
  IGNORE = 4,
  /**
   * REPLACE - / Replaces the conflicting row in case of a collision (e.g. unique
   * / constraint).
   */
  REPLACE = 5,
  UNRECOGNIZED = -1,
}

export function conflictResolutionStrategyFromJSON(object: any): ConflictResolutionStrategy {
  switch (object) {
    case 0:
    case "CONFLICT_RESOLUTION_STRATEGY_UNDEFINED":
      return ConflictResolutionStrategy.CONFLICT_RESOLUTION_STRATEGY_UNDEFINED;
    case 1:
    case "ABORT":
      return ConflictResolutionStrategy.ABORT;
    case 2:
    case "ROLLBACK":
      return ConflictResolutionStrategy.ROLLBACK;
    case 3:
    case "FAIL":
      return ConflictResolutionStrategy.FAIL;
    case 4:
    case "IGNORE":
      return ConflictResolutionStrategy.IGNORE;
    case 5:
    case "REPLACE":
      return ConflictResolutionStrategy.REPLACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConflictResolutionStrategy.UNRECOGNIZED;
  }
}

export function conflictResolutionStrategyToJSON(object: ConflictResolutionStrategy): string {
  switch (object) {
    case ConflictResolutionStrategy.CONFLICT_RESOLUTION_STRATEGY_UNDEFINED:
      return "CONFLICT_RESOLUTION_STRATEGY_UNDEFINED";
    case ConflictResolutionStrategy.ABORT:
      return "ABORT";
    case ConflictResolutionStrategy.ROLLBACK:
      return "ROLLBACK";
    case ConflictResolutionStrategy.FAIL:
      return "FAIL";
    case ConflictResolutionStrategy.IGNORE:
      return "IGNORE";
    case ConflictResolutionStrategy.REPLACE:
      return "REPLACE";
    case ConflictResolutionStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PermissionFlag {
  PERMISSION_FLAG_UNDEFINED = 0,
  /** CREATE - Database record insert. */
  CREATE = 1,
  /** READ - Database record read/list, i.e. select. */
  READ = 2,
  /** UPDATE - Database record update. */
  UPDATE = 4,
  /** DELETE - Database record delete. */
  DELETE = 8,
  /** SCHEMA - / Lookup JSON schema for the given record api . */
  SCHEMA = 16,
  UNRECOGNIZED = -1,
}

export function permissionFlagFromJSON(object: any): PermissionFlag {
  switch (object) {
    case 0:
    case "PERMISSION_FLAG_UNDEFINED":
      return PermissionFlag.PERMISSION_FLAG_UNDEFINED;
    case 1:
    case "CREATE":
      return PermissionFlag.CREATE;
    case 2:
    case "READ":
      return PermissionFlag.READ;
    case 4:
    case "UPDATE":
      return PermissionFlag.UPDATE;
    case 8:
    case "DELETE":
      return PermissionFlag.DELETE;
    case 16:
    case "SCHEMA":
      return PermissionFlag.SCHEMA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermissionFlag.UNRECOGNIZED;
  }
}

export function permissionFlagToJSON(object: PermissionFlag): string {
  switch (object) {
    case PermissionFlag.PERMISSION_FLAG_UNDEFINED:
      return "PERMISSION_FLAG_UNDEFINED";
    case PermissionFlag.CREATE:
      return "CREATE";
    case PermissionFlag.READ:
      return "READ";
    case PermissionFlag.UPDATE:
      return "UPDATE";
    case PermissionFlag.DELETE:
      return "DELETE";
    case PermissionFlag.SCHEMA:
      return "SCHEMA";
    case PermissionFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum QueryApiParameterType {
  TEXT = 1,
  BLOB = 2,
  INTEGER = 3,
  REAL = 4,
  UNRECOGNIZED = -1,
}

export function queryApiParameterTypeFromJSON(object: any): QueryApiParameterType {
  switch (object) {
    case 1:
    case "TEXT":
      return QueryApiParameterType.TEXT;
    case 2:
    case "BLOB":
      return QueryApiParameterType.BLOB;
    case 3:
    case "INTEGER":
      return QueryApiParameterType.INTEGER;
    case 4:
    case "REAL":
      return QueryApiParameterType.REAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryApiParameterType.UNRECOGNIZED;
  }
}

export function queryApiParameterTypeToJSON(object: QueryApiParameterType): string {
  switch (object) {
    case QueryApiParameterType.TEXT:
      return "TEXT";
    case QueryApiParameterType.BLOB:
      return "BLOB";
    case QueryApiParameterType.INTEGER:
      return "INTEGER";
    case QueryApiParameterType.REAL:
      return "REAL";
    case QueryApiParameterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum QueryApiAcl {
  QUERY_API_ACL_UNDEFINED = 0,
  WORLD = 1,
  AUTHENTICATED = 2,
  UNRECOGNIZED = -1,
}

export function queryApiAclFromJSON(object: any): QueryApiAcl {
  switch (object) {
    case 0:
    case "QUERY_API_ACL_UNDEFINED":
      return QueryApiAcl.QUERY_API_ACL_UNDEFINED;
    case 1:
    case "WORLD":
      return QueryApiAcl.WORLD;
    case 2:
    case "AUTHENTICATED":
      return QueryApiAcl.AUTHENTICATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryApiAcl.UNRECOGNIZED;
  }
}

export function queryApiAclToJSON(object: QueryApiAcl): string {
  switch (object) {
    case QueryApiAcl.QUERY_API_ACL_UNDEFINED:
      return "QUERY_API_ACL_UNDEFINED";
    case QueryApiAcl.WORLD:
      return "WORLD";
    case QueryApiAcl.AUTHENTICATED:
      return "AUTHENTICATED";
    case QueryApiAcl.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EmailTemplate {
  subject?: string | undefined;
  body?: string | undefined;
}

export interface EmailConfig {
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  smtpUsername?: string | undefined;
  smtpPassword?: string | undefined;
  senderName?: string | undefined;
  senderAddress?: string | undefined;
  userVerificationTemplate?: EmailTemplate | undefined;
  passwordResetTemplate?: EmailTemplate | undefined;
  changeEmailTemplate?: EmailTemplate | undefined;
}

export interface OAuthProviderConfig {
  clientId?: string | undefined;
  clientSecret?: string | undefined;
  providerId?: OAuthProviderId | undefined;
  displayName?: string | undefined;
  authUrl?: string | undefined;
  tokenUrl?: string | undefined;
  userApiUrl?: string | undefined;
  pkce?: boolean | undefined;
}

export interface AuthConfig {
  authTokenTtlSec?: number | undefined;
  refreshTokenTtlSec?: number | undefined;
  oauthProviders: { [key: string]: OAuthProviderConfig };
}

export interface AuthConfig_OauthProvidersEntry {
  key: string;
  value: OAuthProviderConfig | undefined;
}

export interface ServerConfig {
  /**
   * / Application name presented to users, e.g. when sending emails. Default:
   * / "TrailBase".
   */
  applicationName?:
    | string
    | undefined;
  /**
   * / Your final, deployed URL. This url is used to build canonical urls
   * / for emails, OAuth redirects, ... . Default: "http://localhost:4000".
   */
  siteUrl?:
    | string
    | undefined;
  /**
   * /  Max age of logs that will be retained during period logs cleanup. Note
   * /  that this implies that some older logs may persist until the cleanup job
   * /  reruns. Default: 7 days.
   */
  logsRetentionSec?:
    | number
    | undefined;
  /**
   * / Interval at which backups are persisted. Setting it to 0 will disable
   * / backups. Default: 0.
   */
  backupIntervalSec?: number | undefined;
}

export interface RecordApiConfig {
  name?: string | undefined;
  tableName?: string | undefined;
  conflictResolution?: ConflictResolutionStrategy | undefined;
  autofillMissingUserIdColumns?:
    | boolean
    | undefined;
  /** Access control lists. */
  aclWorld: PermissionFlag[];
  aclAuthenticated: PermissionFlag[];
  createAccessRule?: string | undefined;
  readAccessRule?: string | undefined;
  updateAccessRule?: string | undefined;
  deleteAccessRule?: string | undefined;
  schemaAccessRule?: string | undefined;
}

export interface QueryApiParameter {
  name?: string | undefined;
  type?: QueryApiParameterType | undefined;
}

/**
 * / Configuration schema for Query APIs.
 * /
 * / Note that unlike record APIs, query APIs are read-only,
 * / which simplifies authorization.
 * / That said, query APIs are backed by virtual tables, thus in theory, they
 * / could allow writes (unlike views) in the future for module implementations
 * / that allow it such as SQLite's R*-tree.
 */
export interface QueryApiConfig {
  name?: string | undefined;
  virtualTableName?:
    | string
    | undefined;
  /**
   * / Query parameters the Query API will accept and forward to the virtual
   * / table (function) as argument expressions.
   */
  params: QueryApiParameter[];
  /** Read access control. */
  acl?: QueryApiAcl | undefined;
  accessRule?: string | undefined;
}

export interface JsonSchemaConfig {
  name?: string | undefined;
  schema?: string | undefined;
}

export interface Config {
  /**
   * NOTE: These top-level fields currently have to be `required` due to the
   * overly simple approach on how we do config merging (from env vars and
   * vault).
   */
  email: EmailConfig | undefined;
  server: ServerConfig | undefined;
  auth: AuthConfig | undefined;
  recordApis: RecordApiConfig[];
  queryApis: QueryApiConfig[];
  schemas: JsonSchemaConfig[];
}

function createBaseEmailTemplate(): EmailTemplate {
  return { subject: "", body: "" };
}

export const EmailTemplate: MessageFns<EmailTemplate> = {
  encode(message: EmailTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined && message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.body !== undefined && message.body !== "") {
      writer.uint32(18).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailTemplate {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
    };
  },

  toJSON(message: EmailTemplate): unknown {
    const obj: any = {};
    if (message.subject !== undefined && message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.body !== undefined && message.body !== "") {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailTemplate>, I>>(base?: I): EmailTemplate {
    return EmailTemplate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailTemplate>, I>>(object: I): EmailTemplate {
    const message = createBaseEmailTemplate();
    message.subject = object.subject ?? "";
    message.body = object.body ?? "";
    return message;
  },
};

function createBaseEmailConfig(): EmailConfig {
  return {
    smtpHost: "",
    smtpPort: 0,
    smtpUsername: "",
    smtpPassword: "",
    senderName: "",
    senderAddress: "",
    userVerificationTemplate: undefined,
    passwordResetTemplate: undefined,
    changeEmailTemplate: undefined,
  };
}

export const EmailConfig: MessageFns<EmailConfig> = {
  encode(message: EmailConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.smtpHost !== undefined && message.smtpHost !== "") {
      writer.uint32(10).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined && message.smtpPort !== 0) {
      writer.uint32(16).uint32(message.smtpPort);
    }
    if (message.smtpUsername !== undefined && message.smtpUsername !== "") {
      writer.uint32(26).string(message.smtpUsername);
    }
    if (message.smtpPassword !== undefined && message.smtpPassword !== "") {
      writer.uint32(34).string(message.smtpPassword);
    }
    if (message.senderName !== undefined && message.senderName !== "") {
      writer.uint32(90).string(message.senderName);
    }
    if (message.senderAddress !== undefined && message.senderAddress !== "") {
      writer.uint32(98).string(message.senderAddress);
    }
    if (message.userVerificationTemplate !== undefined) {
      EmailTemplate.encode(message.userVerificationTemplate, writer.uint32(170).fork()).join();
    }
    if (message.passwordResetTemplate !== undefined) {
      EmailTemplate.encode(message.passwordResetTemplate, writer.uint32(178).fork()).join();
    }
    if (message.changeEmailTemplate !== undefined) {
      EmailTemplate.encode(message.changeEmailTemplate, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.smtpPort = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.smtpUsername = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.smtpPassword = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.senderName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.senderAddress = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.userVerificationTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.passwordResetTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.changeEmailTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailConfig {
    return {
      smtpHost: isSet(object.smtpHost) ? globalThis.String(object.smtpHost) : "",
      smtpPort: isSet(object.smtpPort) ? globalThis.Number(object.smtpPort) : 0,
      smtpUsername: isSet(object.smtpUsername) ? globalThis.String(object.smtpUsername) : "",
      smtpPassword: isSet(object.smtpPassword) ? globalThis.String(object.smtpPassword) : "",
      senderName: isSet(object.senderName) ? globalThis.String(object.senderName) : "",
      senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
      userVerificationTemplate: isSet(object.userVerificationTemplate)
        ? EmailTemplate.fromJSON(object.userVerificationTemplate)
        : undefined,
      passwordResetTemplate: isSet(object.passwordResetTemplate)
        ? EmailTemplate.fromJSON(object.passwordResetTemplate)
        : undefined,
      changeEmailTemplate: isSet(object.changeEmailTemplate)
        ? EmailTemplate.fromJSON(object.changeEmailTemplate)
        : undefined,
    };
  },

  toJSON(message: EmailConfig): unknown {
    const obj: any = {};
    if (message.smtpHost !== undefined && message.smtpHost !== "") {
      obj.smtpHost = message.smtpHost;
    }
    if (message.smtpPort !== undefined && message.smtpPort !== 0) {
      obj.smtpPort = Math.round(message.smtpPort);
    }
    if (message.smtpUsername !== undefined && message.smtpUsername !== "") {
      obj.smtpUsername = message.smtpUsername;
    }
    if (message.smtpPassword !== undefined && message.smtpPassword !== "") {
      obj.smtpPassword = message.smtpPassword;
    }
    if (message.senderName !== undefined && message.senderName !== "") {
      obj.senderName = message.senderName;
    }
    if (message.senderAddress !== undefined && message.senderAddress !== "") {
      obj.senderAddress = message.senderAddress;
    }
    if (message.userVerificationTemplate !== undefined) {
      obj.userVerificationTemplate = EmailTemplate.toJSON(message.userVerificationTemplate);
    }
    if (message.passwordResetTemplate !== undefined) {
      obj.passwordResetTemplate = EmailTemplate.toJSON(message.passwordResetTemplate);
    }
    if (message.changeEmailTemplate !== undefined) {
      obj.changeEmailTemplate = EmailTemplate.toJSON(message.changeEmailTemplate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailConfig>, I>>(base?: I): EmailConfig {
    return EmailConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailConfig>, I>>(object: I): EmailConfig {
    const message = createBaseEmailConfig();
    message.smtpHost = object.smtpHost ?? "";
    message.smtpPort = object.smtpPort ?? 0;
    message.smtpUsername = object.smtpUsername ?? "";
    message.smtpPassword = object.smtpPassword ?? "";
    message.senderName = object.senderName ?? "";
    message.senderAddress = object.senderAddress ?? "";
    message.userVerificationTemplate =
      (object.userVerificationTemplate !== undefined && object.userVerificationTemplate !== null)
        ? EmailTemplate.fromPartial(object.userVerificationTemplate)
        : undefined;
    message.passwordResetTemplate =
      (object.passwordResetTemplate !== undefined && object.passwordResetTemplate !== null)
        ? EmailTemplate.fromPartial(object.passwordResetTemplate)
        : undefined;
    message.changeEmailTemplate = (object.changeEmailTemplate !== undefined && object.changeEmailTemplate !== null)
      ? EmailTemplate.fromPartial(object.changeEmailTemplate)
      : undefined;
    return message;
  },
};

function createBaseOAuthProviderConfig(): OAuthProviderConfig {
  return {
    clientId: "",
    clientSecret: "",
    providerId: 0,
    displayName: "",
    authUrl: "",
    tokenUrl: "",
    userApiUrl: "",
    pkce: false,
  };
}

export const OAuthProviderConfig: MessageFns<OAuthProviderConfig> = {
  encode(message: OAuthProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== undefined && message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.clientSecret !== undefined && message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.providerId !== undefined && message.providerId !== 0) {
      writer.uint32(24).int32(message.providerId);
    }
    if (message.displayName !== undefined && message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    if (message.authUrl !== undefined && message.authUrl !== "") {
      writer.uint32(98).string(message.authUrl);
    }
    if (message.tokenUrl !== undefined && message.tokenUrl !== "") {
      writer.uint32(106).string(message.tokenUrl);
    }
    if (message.userApiUrl !== undefined && message.userApiUrl !== "") {
      writer.uint32(114).string(message.userApiUrl);
    }
    if (message.pkce !== undefined && message.pkce !== false) {
      writer.uint32(120).bool(message.pkce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.providerId = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.authUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userApiUrl = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.pkce = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthProviderConfig {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
      providerId: isSet(object.providerId) ? oAuthProviderIdFromJSON(object.providerId) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      authUrl: isSet(object.authUrl) ? globalThis.String(object.authUrl) : "",
      tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : "",
      userApiUrl: isSet(object.userApiUrl) ? globalThis.String(object.userApiUrl) : "",
      pkce: isSet(object.pkce) ? globalThis.Boolean(object.pkce) : false,
    };
  },

  toJSON(message: OAuthProviderConfig): unknown {
    const obj: any = {};
    if (message.clientId !== undefined && message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== undefined && message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.providerId !== undefined && message.providerId !== 0) {
      obj.providerId = oAuthProviderIdToJSON(message.providerId);
    }
    if (message.displayName !== undefined && message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.authUrl !== undefined && message.authUrl !== "") {
      obj.authUrl = message.authUrl;
    }
    if (message.tokenUrl !== undefined && message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.userApiUrl !== undefined && message.userApiUrl !== "") {
      obj.userApiUrl = message.userApiUrl;
    }
    if (message.pkce !== undefined && message.pkce !== false) {
      obj.pkce = message.pkce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthProviderConfig>, I>>(base?: I): OAuthProviderConfig {
    return OAuthProviderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthProviderConfig>, I>>(object: I): OAuthProviderConfig {
    const message = createBaseOAuthProviderConfig();
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.providerId = object.providerId ?? 0;
    message.displayName = object.displayName ?? "";
    message.authUrl = object.authUrl ?? "";
    message.tokenUrl = object.tokenUrl ?? "";
    message.userApiUrl = object.userApiUrl ?? "";
    message.pkce = object.pkce ?? false;
    return message;
  },
};

function createBaseAuthConfig(): AuthConfig {
  return { authTokenTtlSec: 0, refreshTokenTtlSec: 0, oauthProviders: {} };
}

export const AuthConfig: MessageFns<AuthConfig> = {
  encode(message: AuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authTokenTtlSec !== undefined && message.authTokenTtlSec !== 0) {
      writer.uint32(8).int64(message.authTokenTtlSec);
    }
    if (message.refreshTokenTtlSec !== undefined && message.refreshTokenTtlSec !== 0) {
      writer.uint32(16).int64(message.refreshTokenTtlSec);
    }
    Object.entries(message.oauthProviders).forEach(([key, value]) => {
      AuthConfig_OauthProvidersEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.authTokenTtlSec = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.refreshTokenTtlSec = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = AuthConfig_OauthProvidersEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.oauthProviders[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig {
    return {
      authTokenTtlSec: isSet(object.authTokenTtlSec) ? globalThis.Number(object.authTokenTtlSec) : 0,
      refreshTokenTtlSec: isSet(object.refreshTokenTtlSec) ? globalThis.Number(object.refreshTokenTtlSec) : 0,
      oauthProviders: isObject(object.oauthProviders)
        ? Object.entries(object.oauthProviders).reduce<{ [key: string]: OAuthProviderConfig }>((acc, [key, value]) => {
          acc[key] = OAuthProviderConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuthConfig): unknown {
    const obj: any = {};
    if (message.authTokenTtlSec !== undefined && message.authTokenTtlSec !== 0) {
      obj.authTokenTtlSec = Math.round(message.authTokenTtlSec);
    }
    if (message.refreshTokenTtlSec !== undefined && message.refreshTokenTtlSec !== 0) {
      obj.refreshTokenTtlSec = Math.round(message.refreshTokenTtlSec);
    }
    if (message.oauthProviders) {
      const entries = Object.entries(message.oauthProviders);
      if (entries.length > 0) {
        obj.oauthProviders = {};
        entries.forEach(([k, v]) => {
          obj.oauthProviders[k] = OAuthProviderConfig.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig>, I>>(base?: I): AuthConfig {
    return AuthConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig>, I>>(object: I): AuthConfig {
    const message = createBaseAuthConfig();
    message.authTokenTtlSec = object.authTokenTtlSec ?? 0;
    message.refreshTokenTtlSec = object.refreshTokenTtlSec ?? 0;
    message.oauthProviders = Object.entries(object.oauthProviders ?? {}).reduce<{ [key: string]: OAuthProviderConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = OAuthProviderConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAuthConfig_OauthProvidersEntry(): AuthConfig_OauthProvidersEntry {
  return { key: "", value: undefined };
}

export const AuthConfig_OauthProvidersEntry: MessageFns<AuthConfig_OauthProvidersEntry> = {
  encode(message: AuthConfig_OauthProvidersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      OAuthProviderConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_OauthProvidersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_OauthProvidersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = OAuthProviderConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_OauthProvidersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? OAuthProviderConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AuthConfig_OauthProvidersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = OAuthProviderConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig_OauthProvidersEntry>, I>>(base?: I): AuthConfig_OauthProvidersEntry {
    return AuthConfig_OauthProvidersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig_OauthProvidersEntry>, I>>(
    object: I,
  ): AuthConfig_OauthProvidersEntry {
    const message = createBaseAuthConfig_OauthProvidersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? OAuthProviderConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return { applicationName: "", siteUrl: "", logsRetentionSec: 0, backupIntervalSec: 0 };
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationName !== undefined && message.applicationName !== "") {
      writer.uint32(10).string(message.applicationName);
    }
    if (message.siteUrl !== undefined && message.siteUrl !== "") {
      writer.uint32(18).string(message.siteUrl);
    }
    if (message.logsRetentionSec !== undefined && message.logsRetentionSec !== 0) {
      writer.uint32(88).int64(message.logsRetentionSec);
    }
    if (message.backupIntervalSec !== undefined && message.backupIntervalSec !== 0) {
      writer.uint32(96).int64(message.backupIntervalSec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.siteUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.logsRetentionSec = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.backupIntervalSec = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : "",
      siteUrl: isSet(object.siteUrl) ? globalThis.String(object.siteUrl) : "",
      logsRetentionSec: isSet(object.logsRetentionSec) ? globalThis.Number(object.logsRetentionSec) : 0,
      backupIntervalSec: isSet(object.backupIntervalSec) ? globalThis.Number(object.backupIntervalSec) : 0,
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.applicationName !== undefined && message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.siteUrl !== undefined && message.siteUrl !== "") {
      obj.siteUrl = message.siteUrl;
    }
    if (message.logsRetentionSec !== undefined && message.logsRetentionSec !== 0) {
      obj.logsRetentionSec = Math.round(message.logsRetentionSec);
    }
    if (message.backupIntervalSec !== undefined && message.backupIntervalSec !== 0) {
      obj.backupIntervalSec = Math.round(message.backupIntervalSec);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerConfig>, I>>(base?: I): ServerConfig {
    return ServerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerConfig>, I>>(object: I): ServerConfig {
    const message = createBaseServerConfig();
    message.applicationName = object.applicationName ?? "";
    message.siteUrl = object.siteUrl ?? "";
    message.logsRetentionSec = object.logsRetentionSec ?? 0;
    message.backupIntervalSec = object.backupIntervalSec ?? 0;
    return message;
  },
};

function createBaseRecordApiConfig(): RecordApiConfig {
  return {
    name: "",
    tableName: "",
    conflictResolution: 0,
    autofillMissingUserIdColumns: false,
    aclWorld: [],
    aclAuthenticated: [],
    createAccessRule: "",
    readAccessRule: "",
    updateAccessRule: "",
    deleteAccessRule: "",
    schemaAccessRule: "",
  };
}

export const RecordApiConfig: MessageFns<RecordApiConfig> = {
  encode(message: RecordApiConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tableName !== undefined && message.tableName !== "") {
      writer.uint32(18).string(message.tableName);
    }
    if (message.conflictResolution !== undefined && message.conflictResolution !== 0) {
      writer.uint32(40).int32(message.conflictResolution);
    }
    if (message.autofillMissingUserIdColumns !== undefined && message.autofillMissingUserIdColumns !== false) {
      writer.uint32(48).bool(message.autofillMissingUserIdColumns);
    }
    writer.uint32(58).fork();
    for (const v of message.aclWorld) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.aclAuthenticated) {
      writer.int32(v);
    }
    writer.join();
    if (message.createAccessRule !== undefined && message.createAccessRule !== "") {
      writer.uint32(90).string(message.createAccessRule);
    }
    if (message.readAccessRule !== undefined && message.readAccessRule !== "") {
      writer.uint32(98).string(message.readAccessRule);
    }
    if (message.updateAccessRule !== undefined && message.updateAccessRule !== "") {
      writer.uint32(106).string(message.updateAccessRule);
    }
    if (message.deleteAccessRule !== undefined && message.deleteAccessRule !== "") {
      writer.uint32(114).string(message.deleteAccessRule);
    }
    if (message.schemaAccessRule !== undefined && message.schemaAccessRule !== "") {
      writer.uint32(122).string(message.schemaAccessRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordApiConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordApiConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.conflictResolution = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autofillMissingUserIdColumns = reader.bool();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.aclWorld.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aclWorld.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.aclAuthenticated.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aclAuthenticated.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createAccessRule = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.readAccessRule = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updateAccessRule = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.deleteAccessRule = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.schemaAccessRule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordApiConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      conflictResolution: isSet(object.conflictResolution)
        ? conflictResolutionStrategyFromJSON(object.conflictResolution)
        : 0,
      autofillMissingUserIdColumns: isSet(object.autofillMissingUserIdColumns)
        ? globalThis.Boolean(object.autofillMissingUserIdColumns)
        : false,
      aclWorld: globalThis.Array.isArray(object?.aclWorld)
        ? object.aclWorld.map((e: any) => permissionFlagFromJSON(e))
        : [],
      aclAuthenticated: globalThis.Array.isArray(object?.aclAuthenticated)
        ? object.aclAuthenticated.map((e: any) => permissionFlagFromJSON(e))
        : [],
      createAccessRule: isSet(object.createAccessRule) ? globalThis.String(object.createAccessRule) : "",
      readAccessRule: isSet(object.readAccessRule) ? globalThis.String(object.readAccessRule) : "",
      updateAccessRule: isSet(object.updateAccessRule) ? globalThis.String(object.updateAccessRule) : "",
      deleteAccessRule: isSet(object.deleteAccessRule) ? globalThis.String(object.deleteAccessRule) : "",
      schemaAccessRule: isSet(object.schemaAccessRule) ? globalThis.String(object.schemaAccessRule) : "",
    };
  },

  toJSON(message: RecordApiConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableName !== undefined && message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.conflictResolution !== undefined && message.conflictResolution !== 0) {
      obj.conflictResolution = conflictResolutionStrategyToJSON(message.conflictResolution);
    }
    if (message.autofillMissingUserIdColumns !== undefined && message.autofillMissingUserIdColumns !== false) {
      obj.autofillMissingUserIdColumns = message.autofillMissingUserIdColumns;
    }
    if (message.aclWorld?.length) {
      obj.aclWorld = message.aclWorld.map((e) => permissionFlagToJSON(e));
    }
    if (message.aclAuthenticated?.length) {
      obj.aclAuthenticated = message.aclAuthenticated.map((e) => permissionFlagToJSON(e));
    }
    if (message.createAccessRule !== undefined && message.createAccessRule !== "") {
      obj.createAccessRule = message.createAccessRule;
    }
    if (message.readAccessRule !== undefined && message.readAccessRule !== "") {
      obj.readAccessRule = message.readAccessRule;
    }
    if (message.updateAccessRule !== undefined && message.updateAccessRule !== "") {
      obj.updateAccessRule = message.updateAccessRule;
    }
    if (message.deleteAccessRule !== undefined && message.deleteAccessRule !== "") {
      obj.deleteAccessRule = message.deleteAccessRule;
    }
    if (message.schemaAccessRule !== undefined && message.schemaAccessRule !== "") {
      obj.schemaAccessRule = message.schemaAccessRule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordApiConfig>, I>>(base?: I): RecordApiConfig {
    return RecordApiConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordApiConfig>, I>>(object: I): RecordApiConfig {
    const message = createBaseRecordApiConfig();
    message.name = object.name ?? "";
    message.tableName = object.tableName ?? "";
    message.conflictResolution = object.conflictResolution ?? 0;
    message.autofillMissingUserIdColumns = object.autofillMissingUserIdColumns ?? false;
    message.aclWorld = object.aclWorld?.map((e) => e) || [];
    message.aclAuthenticated = object.aclAuthenticated?.map((e) => e) || [];
    message.createAccessRule = object.createAccessRule ?? "";
    message.readAccessRule = object.readAccessRule ?? "";
    message.updateAccessRule = object.updateAccessRule ?? "";
    message.deleteAccessRule = object.deleteAccessRule ?? "";
    message.schemaAccessRule = object.schemaAccessRule ?? "";
    return message;
  },
};

function createBaseQueryApiParameter(): QueryApiParameter {
  return { name: "", type: 1 };
}

export const QueryApiParameter: MessageFns<QueryApiParameter> = {
  encode(message: QueryApiParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined && message.type !== 1) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApiParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApiParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApiParameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? queryApiParameterTypeFromJSON(object.type) : 1,
    };
  },

  toJSON(message: QueryApiParameter): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined && message.type !== 1) {
      obj.type = queryApiParameterTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryApiParameter>, I>>(base?: I): QueryApiParameter {
    return QueryApiParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryApiParameter>, I>>(object: I): QueryApiParameter {
    const message = createBaseQueryApiParameter();
    message.name = object.name ?? "";
    message.type = object.type ?? 1;
    return message;
  },
};

function createBaseQueryApiConfig(): QueryApiConfig {
  return { name: "", virtualTableName: "", params: [], acl: 0, accessRule: "" };
}

export const QueryApiConfig: MessageFns<QueryApiConfig> = {
  encode(message: QueryApiConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.virtualTableName !== undefined && message.virtualTableName !== "") {
      writer.uint32(18).string(message.virtualTableName);
    }
    for (const v of message.params) {
      QueryApiParameter.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.acl !== undefined && message.acl !== 0) {
      writer.uint32(64).int32(message.acl);
    }
    if (message.accessRule !== undefined && message.accessRule !== "") {
      writer.uint32(74).string(message.accessRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApiConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApiConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualTableName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.params.push(QueryApiParameter.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.acl = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.accessRule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApiConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      virtualTableName: isSet(object.virtualTableName) ? globalThis.String(object.virtualTableName) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => QueryApiParameter.fromJSON(e))
        : [],
      acl: isSet(object.acl) ? queryApiAclFromJSON(object.acl) : 0,
      accessRule: isSet(object.accessRule) ? globalThis.String(object.accessRule) : "",
    };
  },

  toJSON(message: QueryApiConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.virtualTableName !== undefined && message.virtualTableName !== "") {
      obj.virtualTableName = message.virtualTableName;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => QueryApiParameter.toJSON(e));
    }
    if (message.acl !== undefined && message.acl !== 0) {
      obj.acl = queryApiAclToJSON(message.acl);
    }
    if (message.accessRule !== undefined && message.accessRule !== "") {
      obj.accessRule = message.accessRule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryApiConfig>, I>>(base?: I): QueryApiConfig {
    return QueryApiConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryApiConfig>, I>>(object: I): QueryApiConfig {
    const message = createBaseQueryApiConfig();
    message.name = object.name ?? "";
    message.virtualTableName = object.virtualTableName ?? "";
    message.params = object.params?.map((e) => QueryApiParameter.fromPartial(e)) || [];
    message.acl = object.acl ?? 0;
    message.accessRule = object.accessRule ?? "";
    return message;
  },
};

function createBaseJsonSchemaConfig(): JsonSchemaConfig {
  return { name: "", schema: "" };
}

export const JsonSchemaConfig: MessageFns<JsonSchemaConfig> = {
  encode(message: JsonSchemaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== undefined && message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonSchemaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonSchemaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonSchemaConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
    };
  },

  toJSON(message: JsonSchemaConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== undefined && message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonSchemaConfig>, I>>(base?: I): JsonSchemaConfig {
    return JsonSchemaConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonSchemaConfig>, I>>(object: I): JsonSchemaConfig {
    const message = createBaseJsonSchemaConfig();
    message.name = object.name ?? "";
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseConfig(): Config {
  return { email: undefined, server: undefined, auth: undefined, recordApis: [], queryApis: [], schemas: [] };
}

export const Config: MessageFns<Config> = {
  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      EmailConfig.encode(message.email, writer.uint32(18).fork()).join();
    }
    if (message.server !== undefined) {
      ServerConfig.encode(message.server, writer.uint32(26).fork()).join();
    }
    if (message.auth !== undefined) {
      AuthConfig.encode(message.auth, writer.uint32(34).fork()).join();
    }
    for (const v of message.recordApis) {
      RecordApiConfig.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.queryApis) {
      QueryApiConfig.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.schemas) {
      JsonSchemaConfig.encode(v!, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = EmailConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.server = ServerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.auth = AuthConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recordApis.push(RecordApiConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.queryApis.push(QueryApiConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.schemas.push(JsonSchemaConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      email: isSet(object.email) ? EmailConfig.fromJSON(object.email) : undefined,
      server: isSet(object.server) ? ServerConfig.fromJSON(object.server) : undefined,
      auth: isSet(object.auth) ? AuthConfig.fromJSON(object.auth) : undefined,
      recordApis: globalThis.Array.isArray(object?.recordApis)
        ? object.recordApis.map((e: any) => RecordApiConfig.fromJSON(e))
        : [],
      queryApis: globalThis.Array.isArray(object?.queryApis)
        ? object.queryApis.map((e: any) => QueryApiConfig.fromJSON(e))
        : [],
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => JsonSchemaConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = EmailConfig.toJSON(message.email);
    }
    if (message.server !== undefined) {
      obj.server = ServerConfig.toJSON(message.server);
    }
    if (message.auth !== undefined) {
      obj.auth = AuthConfig.toJSON(message.auth);
    }
    if (message.recordApis?.length) {
      obj.recordApis = message.recordApis.map((e) => RecordApiConfig.toJSON(e));
    }
    if (message.queryApis?.length) {
      obj.queryApis = message.queryApis.map((e) => QueryApiConfig.toJSON(e));
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => JsonSchemaConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.email = (object.email !== undefined && object.email !== null)
      ? EmailConfig.fromPartial(object.email)
      : undefined;
    message.server = (object.server !== undefined && object.server !== null)
      ? ServerConfig.fromPartial(object.server)
      : undefined;
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? AuthConfig.fromPartial(object.auth)
      : undefined;
    message.recordApis = object.recordApis?.map((e) => RecordApiConfig.fromPartial(e)) || [];
    message.queryApis = object.queryApis?.map((e) => QueryApiConfig.fromPartial(e)) || [];
    message.schemas = object.schemas?.map((e) => JsonSchemaConfig.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
