---
title: >
  First App: UI & Custom Endpoints
---

import { Code } from "@astrojs/starlight/components";
import { Aside } from "@astrojs/starlight/components";

In this tutorial, we'll set up a coffee database, implement a custom TypeScript
HTTP handler for performing vector searches, and a simple production-ready web app
all in ~100 lines of code.


<div class="flex justify-center">
  <div class="w-[80%] shadow-lg	 ">
    ![screenshot](../../../../../examples/coffeesearch/assets/screenshot.png)
  </div>
</div>

<div class="h-[24px]" />

This introductory tutorial is part of the main TrailBase code repository, which
you can download to follow along running:

```bash
$ git clone https://github.com/trailbaseio/trailbase.git
$ cd trailbase/examples/coffeesearch
```

import GettingTrailBase from "./_getting_trailbase.md";

<Aside type="note" title="Getting TrailBase">
  <GettingTrailBase/>
</Aside>

## Importing Data

We'll use the `sqlite3` CLI directly to import
`examples/coffeesearch/arabica_data_cleaned.csv` with the following SQL script[^1]:

```sql
-- First create the strictly typed "coffee" table.
CREATE TABLE IF NOT EXISTS coffee (
  Species TEXT,
  Owner TEXT,

  Aroma REAL,
  Flavor REAL,
  Acidity REAL,
  Sweetness REAL,

  embedding BLOB
) STRICT;

-- Then import the data into a "temporary" table.
.mode csv
.import arabica_data_cleaned.csv temporary

-- Then import the temporary data into the "coffee" table.
INSERT INTO coffee (Species, Owner, Aroma, Flavor, Acidity, Sweetness)
SELECT
  Species,
  Owner,

  CAST(Aroma AS REAL) AS Aroma,
  CAST(Flavor AS REAL) AS Flavor,
  CAST(Acidity AS REAL) AS Acidity,
  CAST(Sweetness AS REAL) AS Sweetness
FROM temporary;

-- And clean up.
DROP TABLE temporary;
```

Note that we didn't initialize the vector `embedding`. This is because the
`sqlite3` CLI doesn't have the necessary extensions built-in.
We'll update the entries to add the embedding later as part of a TrailBase
migration.

While in `example/coffeesearch`, you can run

```bash
$ cat import.sql | sqlite3 traildepot/data/main.db -
```

to execute above script.

After the initial data import and still in the same directory, let's start the
`trail` binary for the first time:

```bash
$ trail run
```

This will apply the migrations under `examples/coffeesearch/traildepot/migrations`, basically

```sql
UPDATE coffee SET embedding = VECTOR(FORMAT("[%f, %f, %f, %f]", Aroma, Flavor, Acidity, Sweetness));
```

to initialize the previously missing `coffee.embedding` for all records.


## Custom TypeScript Endpoint

Starting `trail` also executes JavaScript and TypeScript files under
`traildepot/scripts`.

<Aside type="note">
  TrailBase will automatically transpile TypeScript to JavaScript which can
  then execute on the underlying V8 engine. You don't need a separate build
  step.
</Aside>

We can use this to register custom HTTP endpoints among other things.
Let's have a quick look at `examples/coffeesearch/traildepot/scripts/main.ts`,
which defines a `/search` API route we'll later use in our application to
find coffees most closely matching our desired coffee notes:

import handlerCode from "../../../../../examples/coffeesearch/traildepot/scripts/main.ts?raw";

<Code
  code={handlerCode}
  lang="ts"
  title={"examples/coffeesearch/traildepot/scripts/main.ts"}
  mark={[]}
/>

While `trail run` is up, we can test the public `/search` endpoint simply by
running:

```bash
$ curl "http://localhost:4000/search?aroma=8&flavor=8&acidity=8&sweetness=8"
[
  ["juan luis alvarado romero",7.92,7.58,7.58,8],
  ["eileen koyanagi",7.5,7.33,7.58,8],
  ...
]
```

That's it, we're done with the server side. This is enough to build a simple
search UI.
With little code and a few commands we've ingested CSV data and built a custom
HTTP endpoint using vector search.
If you're not interested in a UI, the same approach setup could be used to
identify relevant documents for AI applications.

## A simple Web UI

After setting up our database, vector search and APIs, we should probably use
them for good measure. For example, we could build a mobile app, have an LLM
answer coffee prompts, or build a small web UI.
Here we'll do the latter. It's quick and also lets us touch more generally on
bundling and deploying web applications with TrailBase.

Note that this is not a web dev tutorial. The specifics of the UI aren't the
focus. We chose React as a well-known option and kept the implementation to
less than 80 lines of code.
In case you want to build your own, we recommend
[vite](https://vite.dev/guide/) to quickly set up an SPA with your favorite JS
framework, e.g.: `npm create vite@latest my-project -- --template react`.

Our provided reference implementation, renders 4 numeric input fields to search
for coffee with a given aroma, flavor, acidity and sweetness score:

import uiCode from "../../../../../examples/coffeesearch/src/App.tsx?raw";

<Code
  code={uiCode}
  lang="ts"
  title={"examples/coffeesearch/src/App.tsx"}
  mark={[]}
/>

We can start a dev-server with the UI from above and hot-reload running:

```bash
$ npm install && npm dev
```

## Deployment: Putting Everything Together

Whether you've followed along or skipped to here, we can now put everything
together.
Let's start by compiling our `JSX/TSX` web UI down to pure HTML, JS, and CSS
artifacts the browser can understand:

```bash
$ npm install && npm build
```

The artifacts are written to `./dist` and can be served alongside our database
as well as custom API by running:

```bash
$ trail run --public-dir dist
```

You can now check out your fuly self-contained app under
[http://localhost:4000/](http://localhost:4000/) or browse the coffee data in
the [admin dashboard](http://localhost:4000/_/admin).

All we need to serve our application in production is[^2]:

- the static `trail` binary,
- the `traildepot` folder containing the data and endpoints,
- the `dist` folder containing our web app.

At the end of the day it's just a bunch of hermetic files without transitively
depending on a pyramid of shared libraries or requiring other services to be up
and running like a separate database server.
This makes it very easy to just copy the files over to your server or bundle
everything in a single container.
`examples/coffeesearch/Dockerfile` is an example of how you can both build and
bundle using Docker. In fact,

```
$ docker build -t coffee . && docker run -p 4000:4000 coffee
```

will speed-run this entire tutorial by building and starting the app listening
at [http://localhost:4000/](http://localhost:4000/).

That's it. We hope this was a fun little introduction showcasing some of
TrailBase's features. If you have any feedback, don't hesitate and reach
out on [GitHub](https://github.com/trailbaseio/trailbase).

<div class="h-[50px]" />

----

[^1]:
    If you don't have `sqlite3` already installed, you can install it using
    `brew install sqlite`, `apt-get install sqlite3`, or
    [download](https://www.sqlite.org/download.html) pre-built binaries

[^2]:
    To serve HTTPS you'll either need a reverse proxy in front to terminate TLS
    or if you don't require end-to-end encryption (e.g. you're not using auth
    or handling sensitive data) you can fall back to TLS termination via a CDN
    like cloudflare.
